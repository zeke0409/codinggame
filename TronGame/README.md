# TronGame by zeke

TronBattleでゴールドリーグに行けたので公開してみるよ。

## TronGame

[TronBattle](https://www.codingame.com/multiplayer/bot-programming/tron-battle)は[CodinGame](https://www.codingame.com/home)が提供するBot Programmingの一つです。

ルールは
- 2~4人ゲーム
- フィールドは30*20
- 各プレイヤーはターン毎に上下左右に進める
- しかし、自他プレイヤーが一度通った場所並びにフィールド外には進めない
- 死んだプレイヤーが通った場所はもう一度通ることができる
- どこにもすすめなくなったら死ぬ
- 最後まで生き残っていたら勝ち

を把握しておけば大丈夫だと思います。

プレビューなどは[こちら](https://www.codingame.com/replay/480039590
)を参考にしてください。


## 言語とその他断り

CodinGameでは様々な言語に対応しており、主要言語ならば大体どれでも書くことができます。しかし、毎ターン実行時間制限100msがありますので、実行速度の速いC++,Rなどといった言語が有利になるでしょう。今回の開発環境はg++ 9.2.1 mode C++17を使用しています。こちらのBasic.cppはブラウザ上へコピペして実際に実行できます。詳しい実行方法などは[こちら](https://qiita.com/javacommons/items/b178c924199d1a6d524d)が参考になります。各種STL,マクロが使用されています。また、~~競プロer特有の~~コードが乱雑な傾向があります。ご了承ください。


## コード概要

- 敵と同じ空間にいるかどうか
    - いる場合
        - αβ探索
        - ボロノイ図貪欲
    - いない場合
        - できるだけ生き延びる


## αβ探索について

αβ探索は探索領域が広すぎるゲーム木を効率的に探索する際に有効ですが、TronGameではあまり有効ではありませんでした。なぜならば、これの評価関数を計算する際にグラフの葉の状態から各プレイヤーから何マス進める領域が存在するかを数えるのですが、一回計算するのにフィールドの大きさ(30×20)分だけ必要とするからです。この影響で最大深さ4までしか探索することができず、よい手を出せるとは考えられないからです。ゆえに、今回は実装しましたが実際には使用していません。~~実装するのにめっちゃ時間かかったので悔しい。~~　これを採用するには評価関数の計算量削減の工夫がいるでしょう。

## ボロノイ図について

これはゴールドリーグ以上を目指す人にとって必須のアルゴリズムとなるでしょう。ボロノイ図に関しては[こちらのサイト](http://www.ics.kagoshima-u.ac.jp/~fuchida/edu/algorithm/voronoi-diagram/voronoi-diagram.html)が分かりやすかったので参考にしてください。今回の場合、上下左右に一マス動かしたときに、自分を中心としたボロノイ領域が最大となるものを貪欲に取るのがよいです。[これ](https://www.codingame.com/replay/480065627
)などは分かりやすいのですが、相手の領域を広げるのを食い止めながら自領域を最大化しようとします。このアルゴリズムを組んだ1vs1の場合では、勝ち負けはほぼ初期位置に依存するでしょう。実装も軽いです。また、1vs多の場合は単純なボロノイ図では難しいです。

## 敵が自分と同じ領域にいない場合
この場合は敵の存在を気にしないでいいので、限られた領域をできるだけ長いターン数をかけて塗り切ることが大事になってきます。いろいろ試しましたが以下の手順が一番いいと思います。

- 一手先読みしていける領域が最も多いものを選ぶ
- 一手先読みで候補がいくつかあるならば二手先読みをする
- 二手先読みでも決まらなければ一手先の状態で、最も壁orすでに通った座標と多く接している方向を選ぶ

三手以上読んでみたりもしたのですが、計算量が増える割に改善されなかったので二手先読みで止めておくのがいいと思います。この手順を踏めば、ほぼ完璧に近い動作をするでしょう。

## 最後に
この他にも、いろいろな工夫をしていますが些末なものですので割愛します。ゴールドリーグになるとプレイヤー数が最大四人になる関係上、先読みが非常に難しくなるためMCTSのような乱択アルゴリズムの実装が必要になるでしょう。